# 从allocator开始的原因
STL实际上定义了一系列高度泛化和高效的数据结构，既然是数据结构，避免不了需要关注内存空间的分配，而Allocator空间配置器的原理的学习，有助于从本质上理解各个组件。

# new 和 delete的使用特点
1. c++中使用new有两个步骤，（1）分配内存（2）构造对象
2. c++中使用delete有两个步骤，（1）析构对象（2）释放内存

# allocator介绍
## construct() 和 destroy()
1. 由于new和delete均有两个步骤，则STL将其过程分开，由此进行一个解耦的操作，能够更加灵活的操作内存空间
2. STL实际上将分配内存和对象的构造析构分成两个文件，分别为<stl_construct.h>、<stl_alloc.h>
   construct文件中包括construct和destroy两个函数，分别负责对象的构造和析构
   alloc文件包括一级，二级配置器，他们负责不同大小的内存块的分配
## construct.h文件
负责对象的构造和析构
1. 构造->使用construct进行分配内存
2. 析构->使用destroy（）进行析构
构造这一部分没什么重点，但是在destroy，有几个特点
1. 对象是否需要进行析构，析构与否对系统造成的影响大不大
2. 当进行大量对象的析构，对象析构的影响是否能够优于析构操作，即析构操作的开销花费是否可能高于对象析构的影响。
则destroy会针对上述情况做出判断，当一些无关痛痒的对象的析构不影响全局反而浪费析构操作的开销的情况下，则不进行析构操作。而其反面，则需要对所有对象进行析构。

如何进行判断对象是否值得析构操作，则由后续内容解释。
## alloc.h文件
负责内存的配置和释放
系统负责栈区的内存分配。而我们则需考虑堆区的内存分配

分配内存要注意处理的几个点
1. 内存不足如何处理
2. 内存是有限的，当小型区块产生的内存碎片问题如何解决
3. 多线程状态

STL以malloc和free完成内存的配置与释放，考虑到内存碎片的问题，STL对不同大小的内存块采用分级分配的策略，能够充分满足不同大小内存的分配操作
### 一级配置器，用于配置较大的内存块
一级配置器采用malloc（）、free（）、realloc（）进行分配内存，而当内存不足时，使用oom_malloc()、oom_reallorc()解决内存不足的问题。
其中，oom_malloc和oom_realloc采用循环不断请求内存的操作以获取满足的内存，如果不这样做，程序就丢出bad_alloc异常信息或终止，后者造成的损伤是很严重的，因此采用不断轮询的操作来请求内存。
### 二级配置器，用于分配较小的内存块
二级配置器，如果区块过大（超过128bytes），则由一级配置器处理。否则，以内存池的方式管理内存，维护对应的内存链表
当请求的内存需求不满足8的倍数时，二级配置器会主动将请求的大小上调至8的倍数，维护16个逐倍递增的8的倍数大小的自由链表。
   维护链表的开销使用union，尽量节省内存的开销
   当内存空间不够时，二级配置器会申请20个或更多内存空间填充链表，若需要更大，可能直接向一级配置器请求，因为一级配置器存在oom操作，不容易抛出异常
uninitialized_copy在内存区块上构造元素，要么构造成功，要么一个都不构造  迭代器first,迭代器lase，目标对象result
uninitialized_fill填充对象，要么构造成功，要么一个都不构造  迭代器first,迭代器last,const T& x
uninitialized_fill_n填充对象，要么构造成功，要么一个都不构造  迭代器First,Size n,const T& x

### POD数据
为了与传统数据分开，命名叫POD数据，即Plain old data,表示传统数据，如果是传统数据如int*,char*等，使用传统最有效率的复制手法(C语言算法如memmove())
而非传统数据，则需要进行手动构造。POD数据的判断，在第三章trivial中介绍。
好处：对传统数据提供高效率，对非传统数据同样也存在处理。
坏处：存在一个不易理解的trivial（站在语言的角度上也是好处）